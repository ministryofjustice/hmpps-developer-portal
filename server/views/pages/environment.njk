{% extends "../partials/layout.njk" %}
{% from "govuk/components/back-link/macro.njk" import govukBackLink %}

{% set pageTitle = applicationName + " - " + component.name %}
{% set mainClasses = "app-container govuk-body" %}

{% block content %}

{{ govukBackLink({
  text: "Back",
  href: "/components/" + component.name
}) }}

<h1 id="detailPageTitle">{{ component.name }} / {{ component.environment.name }}</h1>

<table class="componentData">
  <tbody>
    <tr>
      <th>Name</th>
      <td>{{ component.environment.name }}</td>
    </tr>
    <tr>
      <th>Type</th>
      <td>{{ component.environment.type }}</td>
    </tr>
    <tr>
      <th>URL</th>
      <td><a href="{{ component.environment.url }}">{{ component.environment.url }}</a></td>
    </tr>
    {% if component.api %}
    <tr>
      <th>Swagger</th>
      <td><a href="{{ component.environment.url }}/swagger-ui/index.html" target="_blank">View</a> (opens in new window)</td>
    </tr>
    {% endif %}
    <tr>
      <th>Namespace</th>
      <td><a href="https://github.com/ministryofjustice/cloud-platform-environments/tree/main/namespaces/live.cloud-platform.service.justice.gov.uk/{{ component.environment.namespace }}" target="_blank">{{ component.environment.namespace }}</a> (opens in new window)</td>
    </tr>
    <tr>
      <th>Info</th>
      <td>{% if component.environment.info_path|length %}<a href="{{ component.environment.url }}{{ component.environment.info_path }}" target="_blank">{{ component.environment.info_path }}</a> (opens in new window){% endif %}</td>
    </tr>
    <tr>
      <th>Health</th>
      <td>{% if component.environment.health_path|length %}<a href="{{ component.environment.url }}{{ component.environment.health_path }}" target="_blank">{{ component.environment.health_path }}</a> (opens in new window){% endif %}</td>
    </tr>
    <tr>
      <th>Cluster</th>
      <td>{{ component.environment.cluster }}</td>
    </tr>
    <tr>
      <th>Version</th>
      <td id="{{ component.environment.name }}_version"></td>
    </tr>
    <tr>
      <th>Status</th>
      <td id="{{ component.environment.name }}_status"></td>
    </tr>
    <tr>
      <th>Health output</th>
      <td><pre id="{{ component.environment.name }}_health_raw">None available</pre></td>
    </tr>
    <tr>
      <th>Last Updated</th>
      <td id="{{ component.environment.name }}_last_updated"></td>
    </tr>
    <tr>
      <th>Cloud Platform Reports</th>
      <td><a href="https://reports.cloud-platform.service.justice.gov.uk/namespace/{{ component.environment.namespace }}" target="_blank">View</a> (opens in new window)</td>
    </tr>
  </tbody>
</table>

<h2>Health status history</h2>
<div id="healthTimeline"></div>

{% endblock %}

{% block bodyEnd %}
  <script src="/assets/govuk/all.js"></script>
  <script src="/assets/govukFrontendInit.js"></script>
  <script src="/assets/moj/all.js"></script>

  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

  <script nonce="{{ cspNonce }}">
    function drawChart(stream) {
      const container = document.getElementById('healthTimeline')
      const chart = new google.visualization.Timeline(container)

      const options = {
        avoidOverlappingGridLines: false,
        timeline: { 
          groupByRowLabel: true,
          colorByRowLabel: false}
      };
      const dataTable = new google.visualization.DataTable()
      dataTable.addColumn({ type: 'string', id: 'Status' })
      dataTable.addColumn({ type: 'string', id: 'DummyLabel' })
      dataTable.addColumn({ type: 'string', role: 'tooltip' })
      dataTable.addColumn({ type: 'string', id: 'style', role: 'style' })
      dataTable.addColumn({ type: 'date', id: 'Start' })
      dataTable.addColumn({ type: 'date', id: 'End' })
      
      // Start at from last 20
      const offset = 20
      let i = stream.length - offset
      while (i < stream.length) {
        const eventEpochTime = parseInt(stream[i].id.split('-')[0])
        const eventTimeStart = new Date(eventEpochTime)
        let eventTimeEnd = new Date(eventEpochTime + 120000) // make events 2 min long
        
        if(stream[i+1]) {
          const nextEventEpochTime = parseInt(stream[i+1].id.split('-')[0])
          eventTimeEnd = new Date(nextEventEpochTime - 10000);
        }

        let prettyJson = stream[i].message.json

        try { 
          const messageJson = JSON.parse(stream[i].message.json)
          prettyJson = JSON.stringify(messageJson, null, 2)
        } catch(err) {
          console.error(err)
        }

        prettyJson = `<pre class="healthOutputHover">${prettyJson}</pre>`

        if(stream[i].message.http_s === '200') {
          dataTable.addRows([
            [ 'Status', stream[i].message.http_s, prettyJson, '#00703c', eventTimeStart, eventTimeEnd ]
          ]);
        } else if (stream[i].message.http_s === '0') {
          dataTable.addRows([
            [ 'Status', stream[i].message.http_s, prettyJson, '#000000', eventTimeStart, eventTimeEnd ]
          ]);    
        } else {
          dataTable.addRows([
            [ 'Status', stream[i].message.http_s, prettyJson, '#d4351c', eventTimeStart, eventTimeEnd ]
          ]);          
        }
        i++;
      }

      chart.draw(dataTable, options)
    }

    const lastIds = {}
    const data = {}
    let streamData = []
    lastIds['h:{{ component.environment.name }}'] = '0'
    lastIds['i:{{ component.environment.name }}'] = '0'
    lastIds['v:{{ component.environment.name }}'] = '0'
    data['h:{{ component.environment.name }}'] = ''
    data['i:{{ component.environment.name }}'] = ''
    data['v:{{ component.environment.name }}'] = ''

    const fetchMessages = async (queryStringOptions) => {
      const queryString = new URLSearchParams(queryStringOptions).toString()
      const response = await fetch(`/components/queue/{{ component.name }}/{{ component.environment.name }}/${queryString}`)

      if (!response.ok) {
        throw new Error('There was a problem fetching the component data')
      }

      try {
        const streamJson = await response.json()

        streamJson.forEach(stream => {
          const streamName = stream.name.split(':')
          const streamType = streamName[0].charAt(0)
          const streamKey = `${streamType}:${streamName[2]}`
          const lastMessage = stream.messages[stream.messages.length - 1]

          if (lastIds[streamKey]) {
            lastIds[streamKey] = lastMessage.id
          }

          if (data.hasOwnProperty(streamKey)) {
            data[streamKey] = lastMessage.message

            switch (streamType) {
              case 'v':
                $(`#${streamName[2]}_version`).text(data[streamKey].v)
                break
              case 'h':
                const jsonData = data[streamKey].json
                const httpStatus = data[streamKey].http_s
                const lastTime = new Date(parseInt(lastMessage.id.split('-')[0]));

                stream.messages.forEach(message => {
                  streamData.push(message)
                })

                drawChart(streamData)
                let status = 'UNK'

                try {
                  health = JSON.parse(jsonData)

                  if (health.hasOwnProperty('status')) {
                    status = health.status
                  } else {
                    status = health.healthy === true ? 'UP' : 'DOWN'
                  }
                  if (status === 'UNK') {
                    $(`#${streamName[2]}_status`).removeClass('statusTileDown')
                    $(`#${streamName[2]}_status`).removeClass('statusTileUp')
                  } else if (httpStatus === '200') {
                    $(`#${streamName[2]}_status`).removeClass('statusTileDown')
                    $(`#${streamName[2]}_status`).addClass('statusTileUp')
                  } else {
                    $(`#${streamName[2]}_status`).removeClass('statusTileUp')
                    $(`#${streamName[2]}_status`).addClass('statusTileDown')
                  }

                  $(`#${streamName[2]}_health_raw`).text(JSON.stringify(health, null, 2))

                } catch (e) {
                  console.error('Error parsing JSON data')
                  console.error(e)
                }

                $(`#${streamName[2]}_status`).text(status)
                $(`#${streamName[2]}_last_updated`).text(lastTime.toLocaleString())

                break
            }
          }
        })
      } catch (e) {
        console.error(e)
      }
    }

    const watch = async () => {
      await fetchMessages(lastIds)

      setTimeout(watch, 30000)
    }

    jQuery(function () {
      watch()
      google.charts.load("current", {packages:["timeline"]})
    })
  </script>
{% endblock %}
